<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>加算ノイズ透かしデモ</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"ヒラギノ角ゴ ProN",Meiryo,sans-serif;padding:16px}
  canvas{max-width:100%;border:1px solid #ccc;display:block;margin-top:8px}
  label{display:block;margin-top:8px}
  .controls{max-width:900px}
</style>
</head>
<body>
<h1>加算ノイズ透かし（ブラウザのみ）</h1>
<div class="controls">
  <label>元画像: <input type="file" id="baseFile" accept="image/*"></label>
  <label>透かし画像: <input type="file" id="wmFile" accept="image/*"></label>
  <label>透かし強度: <input id="wmStrength" type="range" min="0" max="1" step="0.01" value="0.12"></label>
  <label>ノイズ強度: <input id="noiseStrength" type="range" min="0" max="0.5" step="0.01" value="0.05"></label>
  <label>勾配量: <input id="gradStrength" type="range" min="0" max="1" step="0.01" value="0.4"></label>
  <label>アルファ閾値: <input id="alphaThreshold" type="range" min="0" max="1" step="0.01" value="0.05"> <span id="alphaValue">0.05</span></label>
  <button id="applyBtn">透かしを適用</button>
  <button id="downloadBtn">結果をダウンロード</button>
</div>

<canvas id="outCanvas"></canvas>

<script>
const baseFile = document.getElementById('baseFile');
const wmFile = document.getElementById('wmFile');
const applyBtn = document.getElementById('applyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const canvas = document.getElementById('outCanvas');
const ctx = canvas.getContext('2d');
const alphaSlider = document.getElementById('alphaThreshold');
const alphaValue = document.getElementById('alphaValue');

// 表示を初期化
alphaValue.textContent = alphaSlider.value;
alphaSlider.addEventListener('input', () => { alphaValue.textContent = alphaSlider.value; });

let baseImg = null;
let wmImg = null;

function loadImageFromFile(file, cb){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = () => { URL.revokeObjectURL(url); cb(img); };
  img.src = url;
}

baseFile.addEventListener('change', e => {
  if(!e.target.files[0]) return;
  loadImageFromFile(e.target.files[0], img => baseImg = img);
});
wmFile.addEventListener('change', e => {
  if(!e.target.files[0]) return;
  loadImageFromFile(e.target.files[0], img => wmImg = img);
});

function generateNoise(width, height){
  const arr = new Float32Array(width * height);
  for(let i=0;i<arr.length;i++) arr[i] = (Math.random() * 2 - 1);
  return arr;
}

function applyWatermark() {
  if(!baseImg){ alert('元画像を選択してください'); return; }
  const wmStrength = parseFloat(document.getElementById('wmStrength').value);
  const noiseStrength = parseFloat(document.getElementById('noiseStrength').value);
  const gradStrength = parseFloat(document.getElementById('gradStrength').value);
  const alphaThreshold = parseFloat(document.getElementById('alphaThreshold').value);

  canvas.width = baseImg.width;
  canvas.height = baseImg.height;
  ctx.drawImage(baseImg, 0, 0);

  const baseData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const w = canvas.width, h = canvas.height;

  let wmCanvas = document.createElement('canvas');
  wmCanvas.width = w; wmCanvas.height = h;
  let wctx = wmCanvas.getContext('2d');
  if(wmImg) {
    // 透かし画像は拡大せず、必要なら縮小してアスペクト比を保持したまま中央に描画
    const srcW = wmImg.width;
    const srcH = wmImg.height;
    const scale = Math.min(1, w / srcW, h / srcH); // 上限1: 拡大しない
    const drawW = Math.round(srcW * scale);
    const drawH = Math.round(srcH * scale);
    const dx = Math.floor((w - drawW) / 2);
    const dy = Math.floor((h - drawH) / 2);
    wctx.clearRect(0,0,w,h);
    wctx.drawImage(wmImg, dx, dy, drawW, drawH);
  }
  else {
    wctx.fillStyle = 'rgba(255,255,255,0)';
    wctx.fillRect(0,0,w,h);
    wctx.fillStyle = '#ffffff';
    wctx.globalAlpha = 0.2;
    wctx.beginPath();
    wctx.arc(w/2,h/2,Math.min(w,h)/4,0,Math.PI*2);
    wctx.fill();
    wctx.globalAlpha = 1;
  }
  const wmData = wctx.getImageData(0,0,w,h);
  const noise = generateNoise(w,h);
  const out = baseData;

  for(let y=0;y<h;y++){
    const gy = (y/(h-1));
    const gradFactor = (gy - 0.5) * 2 * gradStrength;
    for(let x=0;x<w;x++){
      const i = (y*w + x)*4;
  const rwm = wmData.data[i]/255;
  const gwm = wmData.data[i+1]/255;
  const bwm = wmData.data[i+2]/255;
  const awm = wmData.data[i+3]/255; // 透過（アルファ）を反映
  // 透過部分は処理しない（UIで調整可能な閾値でスキップ）
  if (awm < alphaThreshold) continue;
  const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
  const n = noise[y*w + x];
  // ノイズもアルファに依存させ、透過部にはノイズが乗らないようにする
  const delta = (wmLum * (1 + gradFactor) + n * noiseStrength * awm) * wmStrength;
      out.data[i  ] = Math.max(0, Math.min(255, out.data[i  ] + delta * 255));
      out.data[i+1] = Math.max(0, Math.min(255, out.data[i+1] + delta * 255));
      out.data[i+2] = Math.max(0, Math.min(255, out.data[i+2] + delta * 255));
    }
  }
  ctx.putImageData(out,0,0);
}

applyBtn.addEventListener('click', applyWatermark);
downloadBtn.addEventListener('click', () => {
  if(canvas.width===0) return;
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.download = 'watermarked.png';
  a.href = url;
  a.click();
});
</script>
</body>
</html>
