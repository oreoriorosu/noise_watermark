<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>加算ノイズ透かしデモ</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"ヒラギノ角ゴ ProN",Meiryo,sans-serif;padding:16px}
  canvas{max-width:100%;border:1px solid #ccc;display:block;margin-top:8px}
  label{display:block;margin-top:8px}
  .controls{max-width:900px}
  /* loading overlay */
  .loading-overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.6);z-index:9999;visibility:hidden;}
  .spinner{width:48px;height:48px;border:6px solid #ddd;border-top-color:#333;border-radius:50%;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<h1>加算ノイズ透かし（ブラウザのみ）</h1>
<div class="controls">
  <label>元画像: <input type="file" id="baseFile" accept="image/*"></label>
  <label>透かし画像: <input type="file" id="wmFile" accept="image/*"></label>
  <label>透かし強度: <input id="wmStrength" type="range" min="0" max="1" step="0.01" value="0.12"></label>
  <label>ノイズ強度: <input id="noiseStrength" type="range" min="0" max="0.5" step="0.01" value="0.05"></label>
  <label>勾配量: <input id="gradStrength" type="range" min="0" max="1" step="0.01" value="0.4"></label>
  <label>アルファ閾値: <input id="alphaThreshold" type="range" min="0" max="1" step="0.01" value="0.05"> <span id="alphaValue">0.05</span></label>
  <label>透かしサイズ (%): <input id="wmScale" type="range" min="10" max="400" step="1" value="100"> <span id="wmScaleValue">100</span> <label style="margin-left:8px"><input id="wmAuto" type="checkbox" checked> 自動</label></label>
  <label>位置: <select id="wmPos"><option value="center">中央</option><option value="top-left">左上</option><option value="top-right">右上</option><option value="bottom-left">左下</option><option value="bottom-right">右下</option></select></label>
  <button id="applyBtn">透かしを適用</button>
  <button id="downloadBtn">結果をダウンロード</button>

  <div id="devControls" style="display:block; border:1px dashed #ccc; padding:8px; margin-top:8px">
    <strong>開発用設定（常時表示）</strong>
    <div style="margin-top:8px">
      <button id="previewMaskBtn">透かしマスクをプレビュー</button>
      <label style="margin-left:8px">除去法: <select id="removeMethod"><option value="simple">単純減算 (既知)</option><option value="ls">相関推定 (LS)</option></select></label>
      <button id="subtractBtn" style="margin-left:8px">ノイズ無視で減算テスト</button>
      <span id="subtractResult" style="margin-left:8px"></span>
      <div style="margin-top:8px">
        <label><input type="checkbox" id="skipWhite"> 白飛び領域では減算を行わない</label>
        <label style="margin-left:12px">白閾値: <input id="whiteThreshold" type="range" min="200" max="255" step="1" value="250"> <span id="whiteThresholdValue">250</span></label>
      </div>
    </div>
  </div>
</div>

<!-- loading overlay (shared) -->
<div id="loadingOverlay" class="loading-overlay" aria-hidden="true"><div class="spinner" role="status" aria-label="loading"></div></div>

<canvas id="outCanvas"></canvas>

<script>
const baseFile = document.getElementById('baseFile');
const wmFile = document.getElementById('wmFile');
const applyBtn = document.getElementById('applyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const canvas = document.getElementById('outCanvas');
const ctx = canvas.getContext('2d');
const alphaSlider = document.getElementById('alphaThreshold');
const alphaValue = document.getElementById('alphaValue');

// 表示を初期化
alphaValue.textContent = alphaSlider.value;
alphaSlider.addEventListener('input', () => { alphaValue.textContent = alphaSlider.value; });
const devControls = document.getElementById('devControls');
const wmScale = document.getElementById('wmScale');
const wmScaleValue = document.getElementById('wmScaleValue');
const wmAuto = document.getElementById('wmAuto');
const wmPos = document.getElementById('wmPos');
const previewMaskBtn = document.getElementById('previewMaskBtn');
const subtractBtn = document.getElementById('subtractBtn');
const subtractResult = document.getElementById('subtractResult');
const skipWhite = document.getElementById('skipWhite');
const whiteThreshold = document.getElementById('whiteThreshold');
const whiteThresholdValue = document.getElementById('whiteThresholdValue');
whiteThresholdValue.textContent = whiteThreshold.value;
whiteThreshold.addEventListener('input', () => { whiteThresholdValue.textContent = whiteThreshold.value; });
const loadingOverlay = document.getElementById('loadingOverlay');

function showLoading(){
  if(!loadingOverlay) return;
  loadingOverlay.style.visibility = 'visible';
  loadingOverlay.setAttribute('aria-hidden','false');
}
function hideLoading(){
  if(!loadingOverlay) return;
  loadingOverlay.style.visibility = 'hidden';
  loadingOverlay.setAttribute('aria-hidden','true');
}

// yield so the browser can render the loading overlay during heavy work
function yieldFrame(){
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}

wmScaleValue.textContent = wmScale.value;
wmScale.addEventListener('input', () => { wmScaleValue.textContent = wmScale.value; });

// For debug/test: store original base pixel data so subtract test can compare
let originalBaseImageData = null;
// small preview canvas for mask/subtraction results
const previewCanvas = document.createElement('canvas');
previewCanvas.style.maxWidth = '100%';
previewCanvas.style.display = 'block';
previewCanvas.style.marginTop = '8px';
let previewAdded = false;

previewMaskBtn.addEventListener('click', () => {
  if(!wmDataGlobal) { alert('まず透かしを適用して透かしデータを生成してください'); return; }
  // show alpha mask in preview canvas
  const w = canvas.width, h = canvas.height;
  previewCanvas.width = w; previewCanvas.height = h;
  const pctx = previewCanvas.getContext('2d');
  const mask = pctx.createImageData(w,h);
  for(let i=0;i<w*h;i++){
    const si = i*4;
    const a = wmDataGlobal.data[si+3];
    mask.data[si] = a; mask.data[si+1] = a; mask.data[si+2] = a; mask.data[si+3] = 255;
  }
  pctx.putImageData(mask,0,0);
  if(!previewAdded){ canvas.parentNode.appendChild(previewCanvas); previewAdded = true; }
});

subtractBtn.addEventListener('click', async () => {
  if(!originalBaseImageData) { alert('まず「透かしを適用」して元画像データを保存してください'); return; }
  if(!wmDataGlobal) { alert('透かしデータがありません。透かしを適用してから実行してください'); return; }
  showLoading();
  await yieldFrame();
  try{
    const w = canvas.width, h = canvas.height;
    // get current image (watermarked)
    const cur = ctx.getImageData(0,0,w,h);
    const out = new ImageData(new Uint8ClampedArray(cur.data), w, h);
    let diffSum = 0;
    const method = document.getElementById('removeMethod').value;
    if(method === 'simple'){
      for(let y=0;y<h;y++){
        if((y & 31) === 0) await yieldFrame();
        const gy = (y/(h-1));
        const gradFactor = (gy - 0.5) * 2 * parseFloat(document.getElementById('gradStrength').value);
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4;
          const rwm = wmDataGlobal.data[i]/255;
          const gwm = wmDataGlobal.data[i+1]/255;
          const bwm = wmDataGlobal.data[i+2]/255;
          const awm = wmDataGlobal.data[i+3]/255;
          if(awm < parseFloat(alphaSlider.value)) continue;
          // skip subtraction on white (blown) areas if enabled
          if(skipWhite && skipWhite.checked){
            const thr = parseInt(whiteThreshold.value, 10);
            const or = originalBaseImageData.data[i];
            const og = originalBaseImageData.data[i+1];
            const ob = originalBaseImageData.data[i+2];
            if(or >= thr && og >= thr && ob >= thr) continue;
          }
          const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
          const wmStrength = parseFloat(document.getElementById('wmStrength').value);
          const deltaEst = (wmLum * (1 + gradFactor)) * wmStrength; // estimate without noise
          // subtract estimated delta
          out.data[i  ] = Math.max(0, Math.min(255, out.data[i  ] - deltaEst*255));
          out.data[i+1] = Math.max(0, Math.min(255, out.data[i+1] - deltaEst*255));
          out.data[i+2] = Math.max(0, Math.min(255, out.data[i+2] - deltaEst*255));
        }
      }
    } else if(method === 'ls'){
      // LS (correlation) estimate of watermark strength r
      // Compute numerator = sum(M * D) and denom = sum(M*M)
      let numer = 0, denom = 0;
      // D = I_watermarked - I_original
      for(let y=0;y<h;y++){
        if((y & 31) === 0) await yieldFrame();
        const gy = (y/(h-1));
        const gradFactor = (gy - 0.5) * 2 * parseFloat(document.getElementById('gradStrength').value);
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4;
          const rwm = wmDataGlobal.data[i]/255;
          const gwm = wmDataGlobal.data[i+1]/255;
          const bwm = wmDataGlobal.data[i+2]/255;
          const awm = wmDataGlobal.data[i+3]/255;
          if(awm < parseFloat(alphaSlider.value)) continue;
          // skip subtraction on white (blown) areas if enabled
          if(skipWhite && skipWhite.checked){
            const thr = parseInt(whiteThreshold.value, 10);
            const or = originalBaseImageData.data[i];
            const og = originalBaseImageData.data[i+1];
            const ob = originalBaseImageData.data[i+2];
            if(or >= thr && og >= thr && ob >= thr) continue;
          }
          const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
          const M = (wmLum * (1 + gradFactor));
          const D = (cur.data[i] - originalBaseImageData.data[i]) / 255.0; // normalize
          numer += M * D;
          denom += M * M;
        }
      }
      const r = denom === 0 ? 0 : numer / denom; // estimated strength
      // subtract r * M
      for(let y=0;y<h;y++){
        if((y & 31) === 0) await yieldFrame();
        const gy = (y/(h-1));
        const gradFactor = (gy - 0.5) * 2 * parseFloat(document.getElementById('gradStrength').value);
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4;
          const rwm = wmDataGlobal.data[i]/255;
          const gwm = wmDataGlobal.data[i+1]/255;
          const bwm = wmDataGlobal.data[i+2]/255;
          const awm = wmDataGlobal.data[i+3]/255;
          if(awm < parseFloat(alphaSlider.value)) continue;
          const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
          const M = (wmLum * (1 + gradFactor));
          const delta = r * M;
          out.data[i  ] = Math.max(0, Math.min(255, out.data[i  ] - delta*255));
          out.data[i+1] = Math.max(0, Math.min(255, out.data[i+1] - delta*255));
          out.data[i+2] = Math.max(0, Math.min(255, out.data[i+2] - delta*255));
        }
      }
      subtractResult.textContent = `LS est r=${r.toFixed(4)}`;
    }
    // compute mean absolute error between originalBaseImageData and out
    let total = 0; let cnt = 0;
    for(let i=0;i<w*h*4;i+=4){
      const dr = Math.abs(originalBaseImageData.data[i] - out.data[i]);
      const dg = Math.abs(originalBaseImageData.data[i+1] - out.data[i+1]);
      const db = Math.abs(originalBaseImageData.data[i+2] - out.data[i+2]);
      total += (dr+dg+db)/3; cnt++;
    }
    const mae = total / cnt;
    subtractResult.textContent = `MAE: ${mae.toFixed(2)} (小さいほど元に戻せている)`;
    // show output in preview
    previewCanvas.width = w; previewCanvas.height = h;
    previewCanvas.getContext('2d').putImageData(out,0,0);
    if(!previewAdded){ canvas.parentNode.appendChild(previewCanvas); previewAdded = true; }
  } finally {
    hideLoading();
  }
});

let baseImg = null;
let wmImg = null;

function loadImageFromFile(file, cb){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = () => { URL.revokeObjectURL(url); cb(img); };
  img.src = url;
}

baseFile.addEventListener('change', e => {
  if(!e.target.files[0]) return;
  loadImageFromFile(e.target.files[0], img => baseImg = img);
});
wmFile.addEventListener('change', e => {
  if(!e.target.files[0]) return;
  loadImageFromFile(e.target.files[0], img => wmImg = img);
});

function generateNoise(width, height){
  const arr = new Float32Array(width * height);
  for(let i=0;i<arr.length;i++) arr[i] = (Math.random() * 2 - 1);
  return arr;
}

// global watermark image data (full-canvas sized ImageData)
let wmDataGlobal = null;

applyBtn.addEventListener('click', async () => {
  if(!baseImg){ alert('元画像を選択してください'); return; }
  if(!wmImg){ alert('透かし画像を選択してください'); return; }
  showLoading();
  await yieldFrame();
  try{
    // set canvas to base image size
    canvas.width = baseImg.naturalWidth || baseImg.width;
    canvas.height = baseImg.naturalHeight || baseImg.height;
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);
    // save original image data for subtraction tests
    originalBaseImageData = ctx.getImageData(0,0,canvas.width, canvas.height);

    // prepare watermark image drawn onto an offscreen canvas the same size as base
    const off = document.createElement('canvas');
    off.width = canvas.width; off.height = canvas.height;
    const octx = off.getContext('2d');
    octx.clearRect(0,0,off.width, off.height);

    // compute scale and position
    const scalePct = parseFloat(wmScale.value) / 100.0;
    let drawW = Math.round(wmImg.naturalWidth * scalePct);
    let drawH = Math.round(wmImg.naturalHeight * scalePct);
    // if auto, downscale to fit inside base without upscaling unless >100%
    if(wmAuto.checked){
      const maxW = Math.round(canvas.width * 0.9);
      const maxH = Math.round(canvas.height * 0.9);
      const fit = Math.min(maxW / wmImg.naturalWidth, maxH / wmImg.naturalHeight, 1.0);
      drawW = Math.round(wmImg.naturalWidth * fit * (parseFloat(wmScale.value) / 100.0));
      drawH = Math.round(wmImg.naturalHeight * fit * (parseFloat(wmScale.value) / 100.0));
    }

    // position
    let dx = 0, dy = 0;
    const pos = wmPos.value;
    if(pos === 'center'){
      dx = Math.round((canvas.width - drawW) / 2);
      dy = Math.round((canvas.height - drawH) / 2);
    } else if(pos === 'top-left'){
      dx = 0; dy = 0;
    } else if(pos === 'top-right'){
      dx = canvas.width - drawW; dy = 0;
    } else if(pos === 'bottom-left'){
      dx = 0; dy = canvas.height - drawH;
    } else if(pos === 'bottom-right'){
      dx = canvas.width - drawW; dy = canvas.height - drawH;
    }

    // draw watermark onto offscreen and read its pixels into wmDataGlobal
    octx.drawImage(wmImg, dx, dy, drawW, drawH);
    wmDataGlobal = octx.getImageData(0,0,off.width, off.height);

    // apply watermark (additive noise + luminance mask)
    const w = canvas.width, h = canvas.height;
    const data = ctx.getImageData(0,0,w,h);
    const noise = generateNoise(w,h);
    const wmStrengthVal = parseFloat(document.getElementById('wmStrength').value);
    const noiseStrengthVal = parseFloat(document.getElementById('noiseStrength').value);
    const gradStrengthVal = parseFloat(document.getElementById('gradStrength').value);
    const alphaThr = parseFloat(alphaSlider.value);

    for(let y=0;y<h;y++){
      if((y & 31) === 0) await yieldFrame();
      const gy = (y/(h-1));
      const gradFactor = (gy - 0.5) * 2 * gradStrengthVal;
      for(let x=0;x<w;x++){
        const i = (y*w + x)*4;
        const rwm = wmDataGlobal.data[i] / 255;
        const gwm = wmDataGlobal.data[i+1] / 255;
        const bwm = wmDataGlobal.data[i+2] / 255;
        const awm = wmDataGlobal.data[i+3] / 255;
        if(awm < alphaThr) continue; // respect transparency
        const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
        const noiseVal = noise[y*w + x];
        const delta = (wmLum * (1 + gradFactor)) * wmStrengthVal + noiseVal * noiseStrengthVal;
        // add delta to RGB channels
        data.data[i  ] = Math.max(0, Math.min(255, data.data[i  ] + delta*255));
        data.data[i+1] = Math.max(0, Math.min(255, data.data[i+1] + delta*255));
        data.data[i+2] = Math.max(0, Math.min(255, data.data[i+2] + delta*255));
      }
    }
    ctx.putImageData(data, 0, 0);
    // ensure preview canvas reflects latest
    if(!previewAdded){ canvas.parentNode.appendChild(previewCanvas); previewAdded = true; }
    previewCanvas.width = w; previewCanvas.height = h;
    previewCanvas.getContext('2d').putImageData(ctx.getImageData(0,0,w,h),0,0);
  } finally {
    hideLoading();
  }
});

downloadBtn.addEventListener('click', () => {
  if(!canvas) return;
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url; a.download = 'watermarked.png';
  document.body.appendChild(a); a.click(); a.remove();
});

</script>
</body>
</html>
