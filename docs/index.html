<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>加算ノイズ透かしデモ</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"ヒラギノ角ゴ ProN",Meiryo,sans-serif;padding:16px}
  canvas{max-width:100%;border:1px solid #ccc;display:block;margin-top:8px}
  label{display:block;margin-top:8px}
  .controls{max-width:900px}
</style>
</head>
<body>
<h1>加算ノイズ透かし（ブラウザのみ）</h1>
<div class="controls">
  <label>元画像: <input type="file" id="baseFile" accept="image/*"></label>
  <label>透かし画像: <input type="file" id="wmFile" accept="image/*"></label>
  <label>透かし強度: <input id="wmStrength" type="range" min="0" max="1" step="0.01" value="0.12"></label>
  <label>ノイズ強度: <input id="noiseStrength" type="range" min="0" max="0.5" step="0.01" value="0.05"></label>
  <label>勾配量: <input id="gradStrength" type="range" min="0" max="1" step="0.01" value="0.4"></label>
  <label>アルファ閾値: <input id="alphaThreshold" type="range" min="0" max="1" step="0.01" value="0.05"> <span id="alphaValue">0.05</span></label>
  <label>透かしサイズ (%): <input id="wmScale" type="range" min="10" max="400" step="1" value="100"> <span id="wmScaleValue">100</span> <label style="margin-left:8px"><input id="wmAuto" type="checkbox" checked> 自動</label></label>
  <label>位置: <select id="wmPos"><option value="center">中央</option><option value="top-left">左上</option><option value="top-right">右上</option><option value="bottom-left">左下</option><option value="bottom-right">右下</option></select></label>
  <button id="applyBtn">透かしを適用</button>
  <button id="downloadBtn">結果をダウンロード</button>

  <div id="devControls" style="display:block; border:1px dashed #ccc; padding:8px; margin-top:8px">
    <strong>開発用設定（常時表示）</strong>
    <div style="margin-top:8px">
      <button id="previewMaskBtn">透かしマスクをプレビュー</button>
      <label style="margin-left:8px">除去法: <select id="removeMethod"><option value="simple">単純減算 (既知)</option><option value="ls">相関推定 (LS)</option></select></label>
      <button id="subtractBtn" style="margin-left:8px">ノイズ無視で減算テスト</button>
      <span id="subtractResult" style="margin-left:8px"></span>
      <div style="margin-top:8px">
        <label><input type="checkbox" id="skipWhite"> 白飛び領域では減算を行わない</label>
        <label style="margin-left:12px">白閾値: <input id="whiteThreshold" type="range" min="200" max="255" step="1" value="250"> <span id="whiteThresholdValue">250</span></label>
      </div>
    </div>
  </div>
</div>

<canvas id="outCanvas"></canvas>

<script>
const baseFile = document.getElementById('baseFile');
const wmFile = document.getElementById('wmFile');
const applyBtn = document.getElementById('applyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const canvas = document.getElementById('outCanvas');
const ctx = canvas.getContext('2d');
const alphaSlider = document.getElementById('alphaThreshold');
const alphaValue = document.getElementById('alphaValue');

// 表示を初期化
alphaValue.textContent = alphaSlider.value;
alphaSlider.addEventListener('input', () => { alphaValue.textContent = alphaSlider.value; });
const devControls = document.getElementById('devControls');
const wmScale = document.getElementById('wmScale');
const wmScaleValue = document.getElementById('wmScaleValue');
const wmAuto = document.getElementById('wmAuto');
const wmPos = document.getElementById('wmPos');
const previewMaskBtn = document.getElementById('previewMaskBtn');
const subtractBtn = document.getElementById('subtractBtn');
const subtractResult = document.getElementById('subtractResult');
const skipWhite = document.getElementById('skipWhite');
const whiteThreshold = document.getElementById('whiteThreshold');
const whiteThresholdValue = document.getElementById('whiteThresholdValue');
whiteThresholdValue.textContent = whiteThreshold.value;
whiteThreshold.addEventListener('input', () => { whiteThresholdValue.textContent = whiteThreshold.value; });

wmScaleValue.textContent = wmScale.value;
wmScale.addEventListener('input', () => { wmScaleValue.textContent = wmScale.value; });

// For debug/test: store original base pixel data so subtract test can compare
let originalBaseImageData = null;
// small preview canvas for mask/subtraction results
const previewCanvas = document.createElement('canvas');
previewCanvas.style.maxWidth = '100%';
previewCanvas.style.display = 'block';
previewCanvas.style.marginTop = '8px';
let previewAdded = false;

previewMaskBtn.addEventListener('click', () => {
  if(!wmDataGlobal) { alert('まず透かしを適用して透かしデータを生成してください'); return; }
  // show alpha mask in preview canvas
  const w = canvas.width, h = canvas.height;
  previewCanvas.width = w; previewCanvas.height = h;
  const pctx = previewCanvas.getContext('2d');
  const mask = pctx.createImageData(w,h);
  for(let i=0;i<w*h;i++){
    const si = i*4;
    const a = wmDataGlobal.data[si+3];
    mask.data[si] = a; mask.data[si+1] = a; mask.data[si+2] = a; mask.data[si+3] = 255;
  }
  pctx.putImageData(mask,0,0);
  if(!previewAdded){ canvas.parentNode.appendChild(previewCanvas); previewAdded = true; }
});

subtractBtn.addEventListener('click', () => {
  if(!originalBaseImageData) { alert('まず「透かしを適用」して元画像データを保存してください'); return; }
  if(!wmDataGlobal) { alert('透かしデータがありません。透かしを適用してから実行してください'); return; }
  const w = canvas.width, h = canvas.height;
  // get current image (watermarked)
  const cur = ctx.getImageData(0,0,w,h);
  const out = new ImageData(new Uint8ClampedArray(cur.data), w, h);
  let diffSum = 0;
  const method = document.getElementById('removeMethod').value;
  if(method === 'simple'){
        for(let y=0;y<h;y++){
      const gy = (y/(h-1));
      const gradFactor = (gy - 0.5) * 2 * parseFloat(document.getElementById('gradStrength').value);
      for(let x=0;x<w;x++){
        const i = (y*w + x)*4;
        const rwm = wmDataGlobal.data[i]/255;
        const gwm = wmDataGlobal.data[i+1]/255;
        const bwm = wmDataGlobal.data[i+2]/255;
        const awm = wmDataGlobal.data[i+3]/255;
            if(awm < parseFloat(alphaSlider.value)) continue;
            // skip subtraction on white (blown) areas if enabled
            if(skipWhite && skipWhite.checked){
              const thr = parseInt(whiteThreshold.value, 10);
              const or = originalBaseImageData.data[i];
              const og = originalBaseImageData.data[i+1];
              const ob = originalBaseImageData.data[i+2];
              if(or >= thr && og >= thr && ob >= thr) continue;
            }
        const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
        const wmStrength = parseFloat(document.getElementById('wmStrength').value);
        const deltaEst = (wmLum * (1 + gradFactor)) * wmStrength; // estimate without noise
        // subtract estimated delta
        out.data[i  ] = Math.max(0, Math.min(255, out.data[i  ] - deltaEst*255));
        out.data[i+1] = Math.max(0, Math.min(255, out.data[i+1] - deltaEst*255));
        out.data[i+2] = Math.max(0, Math.min(255, out.data[i+2] - deltaEst*255));
      }
    }
  } else if(method === 'ls'){
    // LS (correlation) estimate of watermark strength r
    // Compute numerator = sum(M * D) and denom = sum(M*M)
    let numer = 0, denom = 0;
    // D = I_watermarked - I_original
    for(let y=0;y<h;y++){
      const gy = (y/(h-1));
      const gradFactor = (gy - 0.5) * 2 * parseFloat(document.getElementById('gradStrength').value);
      for(let x=0;x<w;x++){
        const i = (y*w + x)*4;
        const rwm = wmDataGlobal.data[i]/255;
        const gwm = wmDataGlobal.data[i+1]/255;
        const bwm = wmDataGlobal.data[i+2]/255;
        const awm = wmDataGlobal.data[i+3]/255;
        if(awm < parseFloat(alphaSlider.value)) continue;
        // skip subtraction on white (blown) areas if enabled
        if(skipWhite && skipWhite.checked){
          const thr = parseInt(whiteThreshold.value, 10);
          const or = originalBaseImageData.data[i];
          const og = originalBaseImageData.data[i+1];
          const ob = originalBaseImageData.data[i+2];
          if(or >= thr && og >= thr && ob >= thr) continue;
        }
        const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
        const M = (wmLum * (1 + gradFactor));
        const D = (cur.data[i] - originalBaseImageData.data[i]) / 255.0; // normalize
        numer += M * D;
        denom += M * M;
      }
    }
    const r = denom === 0 ? 0 : numer / denom; // estimated strength
    // subtract r * M
    for(let y=0;y<h;y++){
      const gy = (y/(h-1));
      const gradFactor = (gy - 0.5) * 2 * parseFloat(document.getElementById('gradStrength').value);
      for(let x=0;x<w;x++){
        const i = (y*w + x)*4;
        const rwm = wmDataGlobal.data[i]/255;
        const gwm = wmDataGlobal.data[i+1]/255;
        const bwm = wmDataGlobal.data[i+2]/255;
        const awm = wmDataGlobal.data[i+3]/255;
        if(awm < parseFloat(alphaSlider.value)) continue;
        const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
        const M = (wmLum * (1 + gradFactor));
        const delta = r * M;
        out.data[i  ] = Math.max(0, Math.min(255, out.data[i  ] - delta*255));
        out.data[i+1] = Math.max(0, Math.min(255, out.data[i+1] - delta*255));
        out.data[i+2] = Math.max(0, Math.min(255, out.data[i+2] - delta*255));
      }
    }
    subtractResult.textContent = `LS est r=${r.toFixed(4)}`;
  }
  // compute mean absolute error between originalBaseImageData and out
  let total = 0; let cnt = 0;
  for(let i=0;i<w*h*4;i+=4){
    const dr = Math.abs(originalBaseImageData.data[i] - out.data[i]);
    const dg = Math.abs(originalBaseImageData.data[i+1] - out.data[i+1]);
    const db = Math.abs(originalBaseImageData.data[i+2] - out.data[i+2]);
    total += (dr+dg+db)/3; cnt++;
  }
  const mae = total / cnt;
  subtractResult.textContent = `MAE: ${mae.toFixed(2)} (小さいほど元に戻せている)`;
  // show output in preview
  previewCanvas.width = w; previewCanvas.height = h;
  previewCanvas.getContext('2d').putImageData(out,0,0);
  if(!previewAdded){ canvas.parentNode.appendChild(previewCanvas); previewAdded = true; }
});

let baseImg = null;
let wmImg = null;

function loadImageFromFile(file, cb){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = () => { URL.revokeObjectURL(url); cb(img); };
  img.src = url;
}

baseFile.addEventListener('change', e => {
  if(!e.target.files[0]) return;
  loadImageFromFile(e.target.files[0], img => baseImg = img);
});
wmFile.addEventListener('change', e => {
  if(!e.target.files[0]) return;
  loadImageFromFile(e.target.files[0], img => wmImg = img);
});

function generateNoise(width, height){
  const arr = new Float32Array(width * height);
  for(let i=0;i<arr.length;i++) arr[i] = (Math.random() * 2 - 1);
  return arr;
}

function applyWatermark() {
  if(!baseImg){ alert('元画像を選択してください'); return; }
  const wmStrength = parseFloat(document.getElementById('wmStrength').value);
  const noiseStrength = parseFloat(document.getElementById('noiseStrength').value);
  const gradStrength = parseFloat(document.getElementById('gradStrength').value);
  const alphaThreshold = parseFloat(document.getElementById('alphaThreshold').value);

  canvas.width = baseImg.width;
  canvas.height = baseImg.height;
  ctx.drawImage(baseImg, 0, 0);

  const baseData = ctx.getImageData(0,0,canvas.width,canvas.height);
  // save original base image data for subtract test
  originalBaseImageData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const w = canvas.width, h = canvas.height;

  let wmCanvas = document.createElement('canvas');
  wmCanvas.width = w; wmCanvas.height = h;
  let wctx = wmCanvas.getContext('2d');
  if(wmImg) {
    // 透かし画像のサイズ/位置を dev UI に従って決定（デフォルトは自動縮小して中央）
    const srcW = wmImg.width;
    const srcH = wmImg.height;
    let scale = 1;
    if(wmAuto && wmAuto.checked){
      scale = Math.min(1, w / srcW, h / srcH); // 自動: 拡大しないで収まる最大値
    } else if(wmScale){
      // allow manual scaling above 100% (e.g., 150% -> 1.5)
      scale = parseFloat(wmScale.value) / 100;
    }
    const drawW = Math.round(srcW * scale);
    const drawH = Math.round(srcH * scale);
    let dx = Math.floor((w - drawW) / 2);
    let dy = Math.floor((h - drawH) / 2);
    if(wmPos){
      const pos = wmPos.value || 'center';
      if(pos === 'top-left'){ dx = 0; dy = 0; }
      else if(pos === 'top-right'){ dx = w - drawW; dy = 0; }
      else if(pos === 'bottom-left'){ dx = 0; dy = h - drawH; }
      else if(pos === 'bottom-right'){ dx = w - drawW; dy = h - drawH; }
      // center is default
    }
    wctx.clearRect(0,0,w,h);
    wctx.drawImage(wmImg, dx, dy, drawW, drawH);
  }
  else {
    wctx.fillStyle = 'rgba(255,255,255,0)';
    wctx.fillRect(0,0,w,h);
    wctx.fillStyle = '#ffffff';
    wctx.globalAlpha = 0.2;
    wctx.beginPath();
    wctx.arc(w/2,h/2,Math.min(w,h)/4,0,Math.PI*2);
    wctx.fill();
    wctx.globalAlpha = 1;
  }
  const wmData = wctx.getImageData(0,0,w,h);
  // expose watermark data for dev tools (preview/subtract)
  window.wmDataGlobal = wmData;
  const noise = generateNoise(w,h);
  const out = baseData;

  for(let y=0;y<h;y++){
    const gy = (y/(h-1));
    const gradFactor = (gy - 0.5) * 2 * gradStrength;
    for(let x=0;x<w;x++){
      const i = (y*w + x)*4;
  const rwm = wmData.data[i]/255;
  const gwm = wmData.data[i+1]/255;
  const bwm = wmData.data[i+2]/255;
  const awm = wmData.data[i+3]/255; // 透過（アルファ）を反映
  // 透過部分は処理しない（UIで調整可能な閾値でスキップ）
  if (awm < alphaThreshold) continue;
  const wmLum = (0.299*rwm + 0.587*gwm + 0.114*bwm) * awm;
  const n = noise[y*w + x];
  // ノイズもアルファに依存させ、透過部にはノイズが乗らないようにする
  const delta = (wmLum * (1 + gradFactor) + n * noiseStrength * awm) * wmStrength;
      out.data[i  ] = Math.max(0, Math.min(255, out.data[i  ] + delta * 255));
      out.data[i+1] = Math.max(0, Math.min(255, out.data[i+1] + delta * 255));
      out.data[i+2] = Math.max(0, Math.min(255, out.data[i+2] + delta * 255));
    }
  }
  ctx.putImageData(out,0,0);
}

applyBtn.addEventListener('click', applyWatermark);
downloadBtn.addEventListener('click', () => {
  if(canvas.width===0) return;
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.download = 'watermarked.png';
  a.href = url;
  a.click();
});
</script>
</body>
</html>
